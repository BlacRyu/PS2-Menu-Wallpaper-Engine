{
	"camera" : 
	{
		"center" : "0.000 0.000 0.000",
		"eye" : "0.000 0.000 100.000",
		"up" : "0.000 1.000 0.000"
	},
	"general" : 
	{
		"ambientcolor" : "0.302 0.302 0.302",
		"bloom" : true,
		"bloomstrength" : 3.5,
		"bloomthreshold" : 0.89999997615814209,
		"camerafade" : false,
		"cameraparallax" : false,
		"cameraparallaxamount" : 0.5,
		"cameraparallaxdelay" : 0.10000000149011612,
		"cameraparallaxmouseinfluence" : 0.0,
		"camerapreview" : false,
		"camerashake" : false,
		"camerashakeamplitude" : 0.5,
		"camerashakeroughness" : 1.0,
		"camerashakespeed" : 3.0,
		"clearcolor" : "0.125 0.098 0.204",
		"clearenabled" : true,
		"farz" : 10000.0,
		"fov" : 
		{
			"user" : "fov",
			"value" : 53.0
		},
		"nearz" : 1.0,
		"orthogonalprojection" : null,
		"skylightcolor" : "1.000 1.000 1.000"
	},
	"objects" : 
	[
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 115,
			"image" : "models/empty.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGMatrix (shared script module)",
			"origin" : "-5.500 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "0.000 0.000 0.000",
			"size" : "512.000 512.000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\n// matrix functions referenced from https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js\n\nconst deg2rad = Math.PI / 180;\nconst rad2deg = 180 / Math.PI;\n\nfunction clamp(x, min, max){ return Math.max(Math.min(x, max), min) }\n\nclass Mat4 {\n\tconstructor(b){\n\t\tif (b instanceof Mat4){\n\t\t\tthis.elements = new Array(4);\n\t\t\tfor(let i = 0; i < 4; i++){\n\t\t\t\tthis.elements[i] = b.elements[i].slice();\n\t\t\t}\n\t\t}\n\t\telse if (arguments.length === 16){\n\t\t\tthis.elements = new Array(4);\n\t\t\tfor(let i = 0; i < 4; i++){\n\t\t\t\tthis.elements[i] = new Array(4);\n\t\t\t\tfor(let j = 0; j < 4; j++){\n\t\t\t\t\tthis.elements[i][j] = arguments[i*4 + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tthis.elements = [\n\t\t\t\t[1, 0, 0, 0],\n\t\t\t\t[0, 1, 0, 0],\n\t\t\t\t[0, 0, 1, 0],\n\t\t\t\t[0, 0, 0, 1]\n\t\t\t];\n\t\t}\n\t}\n\n\n\tprintElements(){\n\t\tfor(let x = 0; x < 4; x++){\n\t\t\tlet line = \"\";\n\t\t\tfor(let y = 0; y < 4; y++){\n\t\t\t\tline += this.elements[x][y].toString() + \" \";\n\t\t\t}\n\t\t\tconsole.log(line);\n\t\t}\n\t}\n\n\n\tmultiply(right){\n\t\tlet a = this.elements;\n\t\tlet b = right.elements;\n\t\tlet r = new Mat4();\n\n\t\tfor (let x = 0; x < 4; x++){\n\t\t\tfor(let y = 0; y < 4; y++){\n\t\t\t\tr.elements[x][y] = a[x][0] * b[0][y] + a[x][1] * b[1][y] + a[x][2] * b[2][y] + a[x][3] * b[3][y];\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\n\tstatic fromAxisAngle(axis, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\tlet t = 1 - cos;\n\t\tlet x = axis.x, y = axis.y, z = axis.z;\n\t\tlet tx = t*x, ty = t*y;\n\n\t\treturn new Mat4(\n\t\t\ttx * x + cos,      tx * y - sin * z,  tx * z + sin * y,  0,\n\t\t\ttx * y + sin * z,  ty * y + cos,      ty * z - sin * x,  0,\n\t\t\ttx * z - sin * y,  ty * z + sin * x,  t * z * z + cos,   0,\n\t\t\t0,                 0,                 0,                 1\n\t\t);\n\t}\n\n\n\tstatic fromPosition(pos){\n\t\treturn new Mat4(\n\t\t\t1, 0, 0, pos.x,\n\t\t\t0, 1, 0, pos.y,\n\t\t\t0, 0, 1, pos.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\t}\n\n\n\ttoPosition(pos){\n\t\tlet m = this.elements;\n\t\treturn new Vec3(m[0][3], m[1][3], m[2][3]);\n\t}\n\n\n\tstatic fromEuler(angles, order){\n\t\tlet r = new Mat4();\n\t\tlet e = angles.multiply(deg2rad);\n\t\tlet sx = Math.sin(e.x), sy = Math.sin(e.y), sz = Math.sin(e.z);\n\t\tlet cx = Math.cos(e.x), cy = Math.cos(e.y), cz = Math.cos(e.z);\n\n\t\tlet o = order;\n\t\tif (typeof(o) !== \"string\")\n\t\t\to = \"XYZ\";\n\n\t\tswitch (o.toUpperCase()){\n\n\t\t\tcase \"XYZ\":\n\t\t\tdefault:\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = -cy * sz;\n\t\t\t\tr.elements[0][2] = sy;\n\n\t\t\t\tr.elements[1][0] = cx * sz + sx * cz * sy;\n\t\t\t\tr.elements[1][1] = cx * cz - sx * sz * sy;\n\t\t\t\tr.elements[1][2] = -sx * cy;\n\n\t\t\t\tr.elements[2][0] = sx * sz - cx * cz * sy;\n\t\t\t\tr.elements[2][1] = sx * cz + cx * sz * sy;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"YXZ\":\n\t\t\t\tr.elements[0][0] = cy * cz + sy * sz * sx;\n\t\t\t\tr.elements[0][1] = sy * cz * sx - cy * sz;\n\t\t\t\tr.elements[0][2] = cx * sy;\n\n\t\t\t\tr.elements[1][0] = cx * sz;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = -sx;\n\n\t\t\t\tr.elements[2][0] = cy * sz * sx - sy * cz;\n\t\t\t\tr.elements[2][1] = sy * sz + cy * cz * sx;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"ZXY\":\n\t\t\t\tr.elements[0][0] = cy * cz - sy * sz * sx\n\t\t\t\tr.elements[0][1] = -cx * sz;\n\t\t\t\tr.elements[0][2] = sy * cz + cy * sz * sx;\n\n\t\t\t\tr.elements[1][0] = cy * sz + sy * cz * sx;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = sy * sz - cy * cz * sx;\n\n\t\t\t\tr.elements[2][0] = -cx * sy;\n\t\t\t\tr.elements[2][1] = sx;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"ZYX\":\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = sx * cz * sy - cx * sz;\n\t\t\t\tr.elements[0][2] = cx * cz * sy + sx * sz;\n\n\t\t\t\tr.elements[1][0] = cy * sz;\n\t\t\t\tr.elements[1][1] = sx * sz * sy + cx * cz;\n\t\t\t\tr.elements[1][2] = cx * sz * sy - sx * cz;\n\n\t\t\t\tr.elements[2][0] = -sy;\n\t\t\t\tr.elements[2][1] = sx * cy;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"YZX\":\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = sx * sy - cx * cy * sz;\n\t\t\t\tr.elements[0][2] = sx * cy * sz + cx * sy;\n\n\t\t\t\tr.elements[1][0] = sz;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = -sx * cz;\n\n\t\t\t\tr.elements[2][0] = -sy * cz;\n\t\t\t\tr.elements[2][1] = cx * sy * sz + sx * cy;\n\t\t\t\tr.elements[2][2] = cx * cy - sx * sy * sz;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// right colur.elementsn\n\t\tr.elements[0][3] = 0;\n\t\tr.elements[1][3] = 0;\n\t\tr.elements[2][3] = 0;\n\t\t\n\t\t// bottor.elements row\n\t\tr.elements[3][0] = 0;\n\t\tr.elements[3][1] = 0;\n\t\tr.elements[3][2] = 0;\n\t\tr.elements[3][3] = 1;\n\n\t\treturn r;\n\t}\n\n\n\ttoEuler(order){\n\t\tlet m = this.elements;\n\t\tlet x,y,z;\n\n\t\tlet o = order;\n\t\tif (typeof(o) !== \"string\")\n\t\t\to = \"XYZ\";\n\n\t\tswitch (o.toUpperCase()){\n\t\t\tcase \"XYZ\":\n\t\t\tdefault:\n\t\t\t\ty = Math.asin(clamp(m[0][2], -1, 1));\n\n\t\t\t\tif (Math.abs(m[0][2] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[2][2]);\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = Math.atan2(m[2][1], m[1][1]);\n\t\t\t\t\tz = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"YXZ\":\n\t\t\t\tx = Math.asin(-clamp(m[1][2], -1, 1));\n\n\t\t\t\tif (Math.abs(m[1][2] < 0.999999)){\n\t\t\t\t\ty = Math.atan2(m[0][2], m[2][2]);\n\t\t\t\t\tz = Math.atan2(m[1][0], m[1][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[0][0]);\n\t\t\t\t\tz = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ZXY\":\n\t\t\t\tx = Math.asin(clamp(m[2][1], -1, 1));\n\n\t\t\t\tif (Math.abs(m[2][1] < 0.999999)){\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[2][2]);\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[1][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = Math.atan2(m[1][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ZYX\":\n\t\t\t\ty = Math.asin(-clamp(m[2][0], -1, 1));\n\n\t\t\t\tif (Math.abs(m[2][0] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(m[2][1], m[2][2]);\n\t\t\t\t\tz = Math.atan2(m[1][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = 0;\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[1][1]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"YZX\":\n\t\t\t\tz = Math.asin(clamp(m[1][0], -1, 1));\n\n\t\t\t\tif (Math.abs(m[1][0] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[1][1]);\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = Math.atan2(m[0][2], m[2][2]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"XZY\":\n\t\t\t\tz = Math.asin(-clamp(m[0][1], -1, 1));\n\n\t\t\t\tif (Math.abs(m[0][1] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(m[2][1], m[1][1]);\n\t\t\t\t\ty = Math.atan2(m[0][2], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[2][2]);\n\t\t\t\t\ty = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tlet euler = new Vec3(x, y, z);\n\t\teuler = euler.multiply(rad2deg);\n\t\treturn euler;\n\t}\n};\n\nshared.Mat4 = Mat4;",
				"value" : false
			}
		},
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 117,
			"image" : "models/empty.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGVector (shared script module)",
			"origin" : "-5.500 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "0.000 0.000 0.000",
			"size" : "512.000 512.000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nclass OMGVector {\n\tstatic rotX(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x, \n\t\t\tvector.y * cos - vector.z * sin,\n\t\t\tvector.y * sin + vector.z * cos)\n\t};\n\n\tstatic rotY(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x * cos + vector.z * sin,\n\t\t\tvector.y, \n\t\t\t-vector.x * sin + vector.z * cos)\n\t};\n\n\tstatic rotZ(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x * cos - vector.y * sin,\n\t\t\tvector.x * sin + vector.y * cos,\n\t\t\tvector.z)\n\t};\n\n\tstatic rotAxis(vec, angle, axis){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\t(cos + (1 - cos) * axis.x * axis.x) * vec.x +\n\t\t\t((1 - cos) * axis.x * axis.y - axis.z * sin) * vec.y +\n\t\t((1 - cos) * axis.x * axis.z + axis.y * sin) * vec.z,\n\n\t\t((1 - cos) * axis.x * axis.y + axis.z * sin) * vec.x +\n\t\t(cos + (1 - cos) * axis.y * axis.y) * vec.y +\n\t\t((1 - cos) * axis.y * axis.z - axis.x * sin) * vec.z,\n\n\t\t((1 - cos) * axis.x * axis.z - axis.y * sin) * vec.x +\n\t\t((1 - cos) * axis.y * axis.z + axis.x * sin) * vec.y +\n\t\t(cos + (1 - cos) * axis.z * axis.z) * vec.z);\n\t};\n\n\tstatic rotVec(vector, angles){\n\t\tlet r = rotX(vector, angles.x);\n\t\tr = rotY(r, angles.y);\n\t\treturn r = rotZ(r, angles.z);\n\t};\n\n\tstatic unrotVec(vector, angles){\n\t\tlet r = rotZ(vector, -angles.x);\n\t\tr = rotY(r, -angles.y);\n\t\treturn r = rotX(r, -angles.z);\n\t};\n\n\tstatic forwardY(angles){\n\t\treturn rotVec(new Vec3(0., 1., 0.), angles);\n\t};\n\n\tstatic forwardZ(angles){\n\t\treturn rotVec(new Vec3(0., 0., 1.), angles);\n\t};\n\n\tforwardX(angles){\n\t\treturn rotVec(new Vec3(1., 0., 0.), angles);\n\t};\n\n\tstatic interpAngle(angle1, angle2, percent){\n\t\tlet a1 = [angle1.x % 360, angle1.y % 360, angle1.z % 360];\n\t\tlet a2 = [angle2.x % 360, angle2.y % 360, angle2.z % 360];\n\t\tlet diff = [];\n\t\tfor (let i = 0; i < 3; i++){\n\t\t\tif (a1[i] < 0)\n\t\t\t\ta1[i] += 360;\n\t\t\tif (a2[i] < 0)\n\t\t\t\ta2[i] += 360;\n\t\t\tdiff[i] = a2[i] - a1[i];\n\t\t\tif (diff[i] > 180)\n\t\t\t\tdiff[i] -= 360;\n\t\t\telse if (diff[i] < -180)\n\t\t\t\tdiff[i] += 360;\n\t\t}\n\t\treturn new Vec3(a1[0] + diff[0] * percent, a1[1] + diff[1] * percent, a1[2] + diff[2] * percent);\n\t};\n\n\tstatic interpPosition(pos1, pos2, percent){\n\t\tlet x = pos1.x + (pos2.x - pos1.x) * percent;\n\t\tlet y = pos1.y + (pos2.y - pos1.y) * percent;\n\t\tlet z = pos1.z + (pos2.z - pos1.z) * percent;\n\t\treturn new Vec3(x, y, z);\n\t};\n\n\tstatic magnitude(vec){\n\t\treturn Math.sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);\n\t}\n\n\tstatic normalize(vec){\n\t\treturn vec.multiply(1 / OMGVector.magnitude(vec));\n\t};\n}\n\nshared.OMGVector = OMGVector;",
				"value" : false
			}
		},
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 113,
			"image" : "models/empty.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Camera (script)",
			"origin" : "-5.500 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "0.000 0.000 0.000",
			"size" : "512.000 512.000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nlet OMGVector = shared.OMGVector;\n\n// Eye-balled positions at various FoVs\nconst posAt30fov = new Vec3(0, 0, 64.0);\nconst posAt40fov = new Vec3(0, 0, 50.0);\nconst posAt53fov = new Vec3(0, 0, 38.0);\nconst posAt90fov = new Vec3(0, 0, 20.0);\nconst posAtStart = new Vec3(0, 0, 250.0);\n\nlet fov = 53;\nlet position = new Vec3(posAtStart);\nlet targetPosition = new Vec3(posAt53fov);\nlet velocity = new Vec3(0, 0, 0);\nlet accel = 100;\n\nfunction lerp(start, end, interp) {\n\treturn start + (end - start) * interp;\n}\nfunction lerpVec3(start, end, interp) {\n\tlet x = lerp(start.x, end.x, interp);\n\tlet y = lerp(start.y, end.y, interp);\n\tlet z = lerp(start.z, end.z, interp);\n\treturn new Vec3(x, y, z);\n}\n\nlet Mode = shared.Mode = {\n\tCLOCK: \"clock\",\n\tAUDIO: \"audio\",\n\tORBS: \"orbs\"\n};\nshared.mode = shared.Mode.CLOCK;\n\n\n// Scene fade transition (to/from orb mode)\nshared.transitionTime = 3.0;\nshared.fade = -1.0;\n\n\n/**\n * @param {Boolean} value (for property 'visible')\n */\nexport function init(value) {\n\n\treturn value;\n}\n\n\n/**\n * @param {Boolean} value (for property 'visible')\n */\nexport function update(value) {\n\tlet dt = Math.min(engine.frametime, 0.05);\n\n\tlet distance = targetPosition.add(position.multiply(-1));\n\tif (OMGVector.magnitude(distance) > 0.1){\n\t\tlet targetVelocity = distance;\n\t\tlet velocityDelta = targetVelocity.add(velocity.multiply(-1));\n\n\t\t//velocity += (targetVelocity - velocity) * accel * dt;\n\t\tvelocity = velocity.add(OMGVector.normalize( velocityDelta ).multiply(Math.min(OMGVector.magnitude(velocityDelta), accel * dt)));\n\n\t\t// position += velocity * dt\n\t\tposition = position.add(velocity.multiply(dt));\n\n\t\tlet cameraTransform = thisScene.getCameraTransforms();\n\t\tcameraTransform.eye = position;\n\t\tthisScene.setCameraTransforms(cameraTransform);\n\t}\n\t\n\t// Scene fade (Orbs mode transition)\n\tif (shared.mode === Mode.ORBS){\n\t\tif (shared.fade > 0)\n\t\t\tshared.fade = Math.max(0.0, shared.fade - dt / shared.transitionTime);\n\t}\n\telse{\n\t\tif (shared.fade < 1)\n\t\t\tshared.fade = Math.min(1.0, shared.fade + dt / shared.transitionTime);\n\t}\n\n\treturn value;\n}\n\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tif (userProperties.mode != undefined){\n\t\tshared.mode = userProperties.mode;\n\t}\n\tif (userProperties.fov != undefined){\n\t\tfov = userProperties.fov;\n\t}\n\n\tupdateCameraTarget()\n\t\n\tif (engine.runtime < 0.1 && shared.mode === Mode.ORBS){\n\t\tshared.fade = 0;\n\t}\n}\n\nfunction updateCameraTarget(){\n\tlet interp = 0;\n\tif (fov < 40){\n\t\tinterp = (fov - 30) / (40-30);\n\t\ttargetPosition = lerpVec3(posAt30fov, posAt40fov, interp);\n\t}\n\telse if (fov < 53){\n\t\tinterp = (fov - 40) / (53-40);\n\t\ttargetPosition = lerpVec3(posAt40fov, posAt53fov, interp);\n\t}\n\telse{\n\t\tinterp = (fov - 53) / (90-53);\n\t\ttargetPosition = lerpVec3(posAt53fov, posAt90fov, interp);\n\t}\n\n\tif (shared.mode === Mode.ORBS){\n\t\ttargetPosition = targetPosition.multiply(0.65);\n\t}\n}",
				"value" : false
			}
		},
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 16,
			"image" : "models/ps2menu.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Clouds",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "10.000 10.000 10.000",
			"size" : "256.000 256.000",
			"solid" : true,
			"visible" : true
		},
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 12,
			"image" : "models/empty.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Prisms (script)",
			"origin" : 
			{
				"script" : "'use strict';\nimport * as WEMath from 'WEMath';\nlet OMGVector = shared.OMGVector;\nlet Mat4 = shared.Mat4;\n\n// Properties\nconst numPrisms = 12;\nconst prismDist = 6.5;\nconst prismScale = new Vec3(0.9, 0.9, 0.9);\n\n\n// Parent rotation\nconst angleSpeed = new Vec3(0, 10, 15);\nconst angleRigidity = 5.0;\nlet targetAngles = new Vec3(0, 0, 0);\n\n\n// Prism local axis rotation\nconst prismAngleSpeed = new Vec3(0, 20, 0);\nlet center = 0.4;\n\n\n// Math Constants\nconst sec2Min = 0.016666666667;\nconst deg2rad = WEMath.deg2rad;\n\n\n// Register assets\nconst prismAsset = engine.registerAsset(\"models/prism/prism.mdl\");\nconst prismBackAsset = engine.registerAsset(\"models/prism/prism_back.mdl\");\nengine.registerAsset(\"scripts/jsmodules/OMGMatrix.js\");\nengine.registerAsset(\"scripts/jsmodules/OMGVector.js\");\n\n\n// User Properties\nlet Mode = shared.Mode;\nlet clockTick = false; // Ignores milliseconds so the prisms snap to their position each second\nlet rotationSmoothing = false; // Has issues due to how matrices get converted back to euler angles\n\n\n\n\n// Prism Object\nclass Prism {\n\tconstructor(layerFront, layerBack, offset, angles){\n\t\tthis.layerBack = layerBack;\n\t\tthis.layerBack.name = \"prism back\";\n\t\tthis.layerFront = layerFront;\n\t\tthis.layerFront.name = \"prism front\";\n\t\tthis.offset = offset;\n\t\tthis.angles = angles;\n\t}\n\n\tsetScale(scale){\n\t\tthis.layerFront.scale = scale;\n\t\tthis.layerBack.scale = scale;\n\t}\n\n\tsetPosition(position){\n\t\tthis.layerFront.origin = position;\n\t\tthis.layerBack.origin = position;\n\t}\n\n\tsetAngles(angles){\n\t\tthis.layerFront.angles = angles;\n\t\tthis.layerBack.angles = angles;\n\t}\n\n\tsetAlpha(alpha){\n\t\tthis.layerFront.alpha = alpha;\n\t\tthis.layerBack.alpha = alpha;\n\t}\n}\n\n// Array of prisms\nlet prisms = [];\n\n/**\n * @param {Vec3} value (for property 'origin')\n */\nexport function init(value) {\n\tfor (let i = 0; i < numPrisms; i++)\n\t{\n\t\tlet angles = new Vec3(0, 0, i * 360 / numPrisms);\n\n\t\tlet localTransform = new Mat4();\n\t\tlocalTransform = localTransform.multiply(Mat4.fromEuler(angles, \"XYZ\"));\n\t\tlocalTransform = localTransform.multiply(Mat4.fromPosition(new Vec3(0, prismDist, 0)));\n\t\tlet position = localTransform.toPosition();\n\t\t\n\t\tlet frontLayer, backLayer;\n\t\tif (i === 0){\n\t\t\tfrontLayer = thisScene.getLayer(\"mainPrism\");\n\t\t\tbackLayer = thisScene.getLayer(\"mainPrism_back\");\n\t\t}\n\t\telse{\n\t\t\tbackLayer = thisScene.createLayer(prismBackAsset);\n\t\t\tfrontLayer = thisScene.createLayer(prismAsset);\n\t\t}\n\n\t\tprisms[i] = new Prism(frontLayer, backLayer, position, angles);\n\n\t\tprisms[i].setScale(new Vec3(0,0,0));\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Vec3} value (for property 'origin')\n */\nexport function update(value) {\n\tlet currentDateTime = new Date();\n\t// Parent object rotation\n\tswitch (shared.mode){\n\t\tcase Mode.CLOCK:\n\t\tdefault:\n\t\t\tlet yaw = 0, roll = 0;\n\t\t\tif (clockTick){\n\t\t\t\tyaw = -(currentDateTime.getSeconds()) * 6;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tyaw = -(currentDateTime.getSeconds() + currentDateTime.getMilliseconds() * .001) * 6;\n\t\t\t\troll = -currentDateTime.getHours() % 12 * 30;\n\t\t\t}\n\t\t\tlet clockTransform = new Mat4();\n\t\t\tclockTransform = clockTransform.multiply(Mat4.fromEuler(new Vec3(0, yaw, roll), \"ZYX\"));\n\t\t\ttargetAngles = clockTransform.toEuler(\"XYZ\");\n\t\t\tbreak;\n\t\t\t// targetAngles = targetAngles.add( angleSpeed.multiply(engine.frametime) );\n\t\t\t// break;\n\t}\n\tif (rotationSmoothing)\n\t\tthisLayer.angles = OMGVector.interpAngle(thisLayer.angles, targetAngles, Math.min(1.0, angleRigidity * engine.frametime));\n\telse\n\t\tthisLayer.angles = targetAngles;\n\n\tlet parentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\tparentTransform = parentTransform.multiply(Mat4.fromEuler(thisLayer.angles, \"XYZ\"));\n\t\n\t// Update Prisms\n\tfor (let i = 0; i < prisms.length; i++)\n\t{\n\t\tprisms[i].angles = prisms[i].angles.add(prismAngleSpeed.multiply(engine.frametime));\n\n\t\tlet prismTransform = new Mat4();\n\t\tprismTransform = prismTransform.multiply(parentTransform);\n\t\tprismTransform = prismTransform.multiply(Mat4.fromPosition(prisms[i].offset));\n\t\tprismTransform = prismTransform.multiply(Mat4.fromEuler(prisms[i].angles, \"ZYX\"));\n\n\t\tprisms[i].setAngles( prismTransform.toEuler(\"ZYX\") );\n\t\tprisms[i].setPosition( prismTransform.toPosition() );\n\n\t\tprisms[i].setScale(prismScale.multiply(WEMath.smoothStep(.25, .8, shared.fade)));\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tlet aspectRatio = (size.x / size.y);\n\tlet offset = 17 * aspectRatio * (2 * center - 1);\n\tthisLayer.origin = new Vec3(offset, 0, 0);\n}\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tif (userProperties.center != undefined){\n\t\tcenter = userProperties.center;\n\t\tresizeScreen(engine.screenResolution);\n\t}\n}\n",
				"value" : "-8.498 0.000 0.000"
			},
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "0.000 0.000 0.000",
			"size" : "512.000 512.000",
			"solid" : true,
			"visible" : false
		},
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 14,
			"image" : "models/empty.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Orbs (script)",
			"origin" : 
			{
				"script" : "'use strict';\nimport * as WEMath from 'WEMath';\nlet OMGVector = shared.OMGVector;\nlet Mat4 = shared.Mat4;\n\n// Properties\nconst numOrbs = 7;\nconst orbDist = 4.5;\n\n// Orb parent rotation (z rotation offset based on orb index)\nconst angleSpeed = new Vec3(0, 110, 90);\n\n\nlet center = 0.4;\n\n\n// Consts\nconst sec2Min = 0.016666666667;\nconst deg2rad = WEMath.deg2rad;\n\n// Register assets and their children\nconst orbAsset = engine.registerAsset(\"particles/orb.json\");\n\tengine.registerAsset(\"orbTrail.json\");\n\tengine.registerAsset(\"orbGlow.json\");\n\n\n// Objects\nlet orbs = [];\nlet parentTransform = new Mat4();\n\n\n// Classes\nclass Orb {\n\tconstructor(offset) {\n\t\tthis.layer = thisScene.createLayer(orbAsset);\n\t\tthis.offset = offset;\n\t}\n\n\tupdate(index, seconds) {\n\t\tlet angleZ = (index+1) * seconds * 360. * sec2Min;\n\t\tlet finalAngles = thisLayer.angles.add(new Vec3(0, 0, angleZ));\n\t\tlet finalParentTransform = parentTransform.multiply(Mat4.fromEuler(finalAngles), \"XYZ\");\n\n\t\tlet localTransform = new Mat4();\n\t\tlocalTransform = localTransform.multiply(Mat4.fromPosition(this.offset));\n\n\t\tlet finalTransform = finalParentTransform.multiply(localTransform);\n\n\t\tthis.layer.origin = finalTransform.toPosition();\n\t}\n}\n\n/**\n * @param {Boolean} value (for property 'visible')\n */\nexport function init(value) {\n\tparentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\n\tlet currentTime = new Date();\n\tlet seconds = currentTime.getHours() * 3600 + currentTime.getMinutes() * 60 + currentTime.getSeconds() + currentTime.getMilliseconds() * 0.001;\n\n\tfor (let i = 0; i < numOrbs; i++) {\n\t\torbs[i] = new Orb(new Vec3(0, orbDist, 0));\n\t\t\n\t\torbs[i].update(i, seconds);\n\t}\n\treturn value;\n}\n\nexport function update(value) {\n\tthisLayer.angles = thisLayer.angles.add( angleSpeed.multiply(engine.frametime) );\n\tparentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\n\tlet currentTime = new Date();\n\tlet seconds = currentTime.getHours() * 3600 + currentTime.getMinutes() * 60 + currentTime.getSeconds() + currentTime.getMilliseconds() * 0.001;\n\n\tfor (let i = 0; i < orbs.length; i++) {\n\t\torbs[i].update(i, seconds);\n\t}\n\treturn value;\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tlet aspectRatio = (size.x / size.y);\n\tlet offset = 17 * aspectRatio * (2 * center - 1);\n\tthisLayer.origin = new Vec3(offset, 0, 0);\n}\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tif (userProperties.center != undefined) {\n\t\tcenter = userProperties.center;\n\t\tresizeScreen(engine.screenResolution);\n\t}\n\t//mode = userProperties.mode;\n}\n",
				"value" : "-5.500 0.000 0.000"
			},
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "0.000 0.000 0.000",
			"size" : "512.000 512.000",
			"solid" : true,
			"visible" : false
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 64,
			"locktransforms" : true,
			"model" : "models/prism/prism_back.mdl",
			"name" : "mainPrism_back",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"scale" : "1.000 1.000 1.000",
			"skin" : 1
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 104,
			"locktransforms" : true,
			"model" : "models/prism/prism.mdl",
			"name" : "mainPrism",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"scale" : "1.000 1.000 1.000",
			"skin" : 1
		},
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 13,
			"image" : "models/empty.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Sounds (script)",
			"origin" : 
			{
				"script" : "'use strict';\nimport * as WEMath from 'WEMath';\n\n// Register asset\nconst noiseAsset = engine.registerAsset(\"sounds/noise.ogg\");\nconst noiseLow100Asset = engine.registerAsset(\"sounds/noise_low_100.ogg\");\nconst noiseLow200Asset = engine.registerAsset(\"sounds/noise_low_200.ogg\");\nconst noiseLow800Asset = engine.registerAsset(\"sounds/noise_low_800.ogg\");\nconst noiseHighAsset = engine.registerAsset(\"sounds/noise_high.ogg\");\n\nclass Range {\n\tconstructor(min, max){\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t\tthis.value = this.rand();\n\t}\n\trand(){\n\t\treturn this.lerp(Math.random());\n\t}\n\tlerp(l){\n\t\treturn this.value = this.min + (this.max - this.min) * l;\n\t}\n\tget(){\n\t\treturn this.value;\n\t}\n\tset(value){\n\t\tthis.value = value;\n\t}\n}\n\nclass SoundLayer {\n\tconstructor(asset, mindelay, maxdelay, minduration, maxduration, minvolume, maxvolume){\n\t\tthis.layer = thisScene.createLayer(asset);\n\t\tthis.layer.stop();\n\t\tthis.layer.volume = 0.0001;\n\t\tthis.delay = new Range(mindelay, maxdelay);\n\t\tthis.remainingDelay = 0;\n\t\tthis.duration = new Range(minduration, maxduration);\n\t\tthis.remainingDuration = 0;\n\t\tthis.volume = new Range(minvolume, maxvolume);\n\n\t\tthis.wasPlaying = false;\n\t}\n\treset(){\n\t\tthis.remainingDelay = this.delay.rand();\n\t\tthis.remainingDuration = this.duration.rand();\n\t\tthis.volume.value = this.volume.rand();\n\t}\n}\n\nclass SoundLayer2 {\n\tconstructor(asset){\n\t\tthis.layer = thisScene.createLayer(asset);\n\t\tthis.layer.volume = 0.2;\n\t}\n}\n\n// Array of prisms\nlet layers = [];\n\n/**\n * @param {Vec3} value (for property 'origin')\n */\nexport function init(value) {\n\t// asset,  mindelay, maxdelay,  minduration, maxduration,  minvolume, maxvolume\n\tlayers[0] = new SoundLayer(noiseLow100Asset,  0,  0,  16, 20,   0.2, 0.25);\n\tlayers[1] = new SoundLayer(noiseLow200Asset,  2,  6,  10, 16,  0.18, 0.3);\n\tlayers[2] = new SoundLayer(noiseLow800Asset,  4, 12,   6, 10,  0.15, 0.2);\n\tlayers[3] = new SoundLayer(noiseHighAsset,    6, 18,   4,  8,  0.08, 0.15);\n\tlayers[4] = new SoundLayer(noiseAsset,        8, 24,   3,  5,  0.03, 0.1);\n\treturn value;\n}\n\n/**\n * @param {Vec3} value (for property 'origin')\n */\nexport function update(value) {\n\tfor (let i = 0; i < layers.length; i++){\n\t\tif (layers[i].wasPlaying && !layers[i].layer.isPlaying())\n\t\t{\n\t\t\tlayers[i].reset();\n\t\t}\n\t\telse if (!layers[i].layer.isPlaying()){\n\t\t\tlayers[i].remainingDelay -= engine.frametime;\n\t\t\tif (layers[i].remainingDelay <= 0)\n\t\t\t\tlayers[i].layer.play();\n\t\t}\n\t\telse{\n\t\t\tlayers[i].remainingDuration -= engine.frametime;\n\t\t\tif (layers[i].remainingDuration <= 0){\n\t\t\t\tlayers[i].layer.stop();\n\t\t\t\tlayers[i].reset();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlet time = 1 - layers[i].remainingDuration / layers[i].duration.get();\n\t\t\t\ttime = WEMath.smoothStep(0, 1, (1 - Math.abs(1 - 2 * time)));\n\t\t\t\tlayers[i].layer.volume = time * layers[i].volume.get();\n\t\t\t\t// keep volume above 0 to reduce popping\n\t\t\t\tlayers[i].layer.volume = Math.max(0.01, layers[i].layer.volume);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n",
				"value" : "-5.500 0.000 0.000"
			},
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "0.000 0.000 0.000",
			"size" : "512.000 512.000",
			"solid" : true,
			"visible" : false
		},
		{
			"alpha" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Number} value (for property 'alpha')\n */\nexport function update(value) {\n\treturn Math.min(0.9, shared.fade);\n}\n",
				"value" : 0.89999997615814209
			},
			"anchor" : "topleft",
			"angles" : "0.000 0.000 0.000",
			"backgroundcolor" : "0.000 0.000 0.000",
			"color" : "0.875 0.875 0.875",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/blurprecise/effect.json",
					"id" : 57,
					"name" : "",
					"passes" : 
					[
						{
							"combos" : 
							{
								"KERNEL" : 2
							},
							"constantshadervalues" : 
							{
								"scale" : "2 2"
							},
							"id" : 60
						},
						{
							"combos" : 
							{
								"KERNEL" : 2,
								"VERTICAL" : 1
							},
							"constantshadervalues" : 
							{
								"scale" : "2 2"
							},
							"id" : 61
						}
					],
					"visible" : true
				}
			],
			"font" : "fonts/NimbusSanL-Reg.ttf",
			"horizontalalign" : "left",
			"id" : 48,
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Current Date",
			"opaquebackground" : false,
			"origin" : "-18.000 14.000 5.000",
			"padding" : 4,
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"pointsize" : 
			{
				"user" : "text_size",
				"value" : 35.0
			},
			"scale" : "0.010 0.010 0.010",
			"size" : "736.000 183.000",
			"solid" : true,
			"text" : 
			{
				"script" : "'use strict';\nimport * as WEMath from 'WEMath';\n\nlet fov = 53;\n\nfunction lerp(start, end, interp) {\n\treturn start + (end - start) * interp;\n}\nfunction lerpVec3(start, end, interp) {\n\tlet x = lerp(start.x, end.x, interp);\n\tlet y = lerp(start.y, end.y, interp);\n\tlet z = lerp(start.z, end.z, interp);\n\treturn new Vec3(x, y, z);\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tlet ratio = size.x / size.y;\n\tlet posAt30fov = new Vec3(-12.8 * ratio, 12.5, 15);\n\tlet posAt40fov = new Vec3(-12.4 * ratio, 12, 15);\n\tlet posAt53fov = new Vec3(-11 * ratio, 11, 15);\n\tlet posAt90fov = new Vec3(-14.5 * ratio, 14, 5);\n\tlet interp = 0;\n\tif (fov < 40){\n\t\tinterp = (fov - 30) / (40-30);\n\t\tthisLayer.origin = lerpVec3(posAt30fov, posAt40fov, interp);\n\t}\n\telse if (fov < 53){\n\t\tinterp = (fov - 40) / (53-40);\n\t\tthisLayer.origin = lerpVec3(posAt40fov, posAt53fov, interp);\n\t}\n\telse{\n\t\tinterp = (fov - 53) / (90-53);\n\t\tthisLayer.origin = lerpVec3(posAt53fov, posAt90fov, interp);\n\t}\n}\n\n/**\n * @param {String} value (for property 'text')\n */\nexport function update(value) {\n\tlet dateTime = new Date();\n\tlet year = dateTime.getFullYear();\n\tlet month = dateTime.getMonth() + 1;\n\tif (month < 10) month = \"0\" + month;\n\tlet day = dateTime.getDate();\n\tif (day < 10) day = \"0\" + day;\n\treturn year + \"/\" + month + \"/\" + day;\n}\n/**\n * @param {String} value (for property 'text')\n */\nexport function init(value) {\n\tresizeScreen(engine.screenResolution);\n\treturn value;\n}\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tif (userProperties.fov != undefined){\n\t\tfov = userProperties.fov;\n\t\tresizeScreen(engine.screenResolution);\n\t}\n}\n",
				"value" : "0000/00/00"
			},
			"verticalalign" : "top",
			"visible" : 
			{
				"user" : "show_clock_text",
				"value" : false
			}
		},
		{
			"alpha" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Number} value (for property 'alpha')\n */\nexport function update(value) {\n\treturn Math.min(0.9, shared.fade);\n}\n",
				"value" : 0.89999997615814209
			},
			"anchor" : "topleft",
			"angles" : "0.000 0.000 0.000",
			"backgroundcolor" : "0.000 0.000 0.000",
			"color" : "0.875 0.875 0.875",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/blurprecise/effect.json",
					"id" : 71,
					"name" : "",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"scale" : "2 2"
							},
							"id" : 72
						},
						{
							"combos" : 
							{
								"VERTICAL" : 1
							},
							"constantshadervalues" : 
							{
								"scale" : "2 2"
							},
							"id" : 73
						}
					],
					"visible" : true
				}
			],
			"font" : "fonts/NimbusSanL-Reg.ttf",
			"horizontalalign" : "right",
			"id" : 19,
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Current Time",
			"opaquebackground" : false,
			"origin" : "14.000 10.000 15.000",
			"padding" : 4,
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"pointsize" : 
			{
				"user" : "text_size",
				"value" : 35.0
			},
			"scale" : "0.010 0.010 0.010",
			"size" : "574.000 183.000",
			"solid" : true,
			"text" : 
			{
				"script" : "'use strict';\n\nlet militaryTime = false;\nlet ampm = \"am\";\n\nlet fov = 53;\n\nfunction lerp(start, end, interp) {\n\treturn start + (end - start) * interp;\n}\nfunction lerpVec3(start, end, interp) {\n\tlet x = lerp(start.x, end.x, interp);\n\tlet y = lerp(start.y, end.y, interp);\n\tlet z = lerp(start.z, end.z, interp);\n\treturn new Vec3(x, y, z);\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tlet ratio = size.x / size.y;\n\tlet posAt30fov = new Vec3(12.8 * ratio, 12.5, 15);\n\tlet posAt40fov = new Vec3(12.4 * ratio, 12, 15);\n\tlet posAt53fov = new Vec3(11 * ratio, 11, 15);\n\tlet posAt90fov = new Vec3(14.5 * ratio, 14, 5);\n\tlet interp = 0;\n\tif (fov < 40){\n\t\tinterp = (fov - 30) / (40-30);\n\t\tthisLayer.origin = lerpVec3(posAt30fov, posAt40fov, interp);\n\t}\n\telse if (fov < 53){\n\t\tinterp = (fov - 40) / (53-40);\n\t\tthisLayer.origin = lerpVec3(posAt40fov, posAt53fov, interp);\n\t}\n\telse{\n\t\tinterp = (fov - 53) / (90-53);\n\t\tthisLayer.origin = lerpVec3(posAt53fov, posAt90fov, interp);\n\t}\n}\n\n/**\n * @param {String} value (for property 'text')\n */\nexport function update(value) {\n\tlet dateTime = new Date();\n\tlet hour = dateTime.getHours();\n\tif (!militaryTime){\n\t\tif (hour > 12)\n\t\t\tampm = \"PM\";\n\t\telse\n\t\t\tampm = \"AM\";\n\t\thour = hour % 12;\n\t}\n\t//if (hour < 10) hour = \"0\" + hour;\n\tlet minute = dateTime.getMinutes();\n\tif (minute < 10) minute = \"0\" + minute;\n\tlet second = dateTime.getSeconds();\n\tif (second < 10) second = \"0\" + second;\n\n\tlet time = hour + \":\" + minute + \":\" + second;\n\tif (!militaryTime)\n\t\ttime = time + \" \" + ampm;\n\treturn time;\n}\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tif (userProperties.fov != undefined){\n\t\tfov = userProperties.fov;\n\t\tresizeScreen(engine.screenResolution);\n\t}\n\tif (userProperties.clock_24_hour != undefined){\n\t\tmilitaryTime = userProperties.clock_24_hour;\n\t}\n}",
				"value" : "00:00:00"
			},
			"verticalalign" : "top",
			"visible" : 
			{
				"user" : "show_clock_text",
				"value" : false
			}
		},
		{
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/filmgrain/effect.json",
					"id" : 68,
					"name" : "",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"scale" : 10,
								"strength" : 
								{
									"user" : "film_grain",
									"value" : 0.38
								}
							},
							"id" : 70,
							"textures" : [ null, "util/noise" ]
						}
					],
					"visible" : true
				}
			],
			"id" : 63,
			"image" : "models/util/fullscreenlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Film Grain",
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"solid" : true,
			"visible" : true
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 110,
			"instanceoverride" : 
			{
				"colorn" : 
				{
					"script" : "'use strict';\n\nlet particleColor = new Vec3(0, 0, 0);\n\n/**\n * @param {Vec3} value (for property 'colorn')\n */\nexport function update(value) {\n\treturn particleColor;\n}\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tparticleColor = userProperties.schemecolor.multiply(0.175);\n}\n",
					"user" : null,
					"value" : "0 0 0"
				},
				"id" : 112
			},
			"locktransforms" : true,
			"name" : "particles",
			"origin" : "0.000 0.000 -40.000",
			"parallaxDepth" : "1.000 1.000",
			"particle" : "particles/particles2.json",
			"scale" : "1.000 1.000 1.000",
			"visible" : true
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 49,
			"locktransforms" : true,
			"maxtime" : 5.0,
			"mintime" : 1.0,
			"muteineditor" : false,
			"name" : "silence.ogg (enables volume controls)",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"playbackmode" : "loop",
			"scale" : "1.000 1.000 1.000",
			"sound" : [ "sounds/silence.ogg" ],
			"startsilent" : true,
			"volume" : 0.0099999997764825821
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 98,
			"locktransforms" : true,
			"model" : "models/prism/prism.mdl",
			"name" : "prism (fixes? a weird script error: \"createLayer cannot be called from global scope\")",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"scale" : "0.000 0.000 0.000"
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 95,
			"locktransforms" : true,
			"model" : "models/prism/prism_back.mdl",
			"name" : "prism_back (fixes? a weird script error: \"createLayer cannot be called from global scope\")",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"scale" : "0.000 0.000 0.000"
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 130,
			"locktransforms" : true,
			"maxtime" : 5.0,
			"mintime" : 1.0,
			"muteineditor" : true,
			"name" : "startup.ogg",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"playbackmode" : "single",
			"scale" : "1.000 1.000 1.000",
			"sound" : [ "sounds/startup.ogg" ],
			"startsilent" : false,
			"volume" : 0.40000000596046448
		}
	]
}