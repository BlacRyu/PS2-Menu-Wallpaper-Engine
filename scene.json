{
	"camera" : 
	{
		"center" : "0.000 0.000 50.000",
		"eye" : "0.000 0.000 51.000",
		"up" : "0.000 1.000 0.000"
	},
	"general" : 
	{
		"ambientcolor" : "0.302 0.302 0.302",
		"bloom" : false,
		"bloomstrength" : 3.0099999904632568,
		"bloomthreshold" : 0.69999998807907104,
		"camerafade" : false,
		"cameraparallax" : false,
		"cameraparallaxamount" : 0.5,
		"cameraparallaxdelay" : 0.10000000149011612,
		"cameraparallaxmouseinfluence" : 0.0,
		"camerapreview" : false,
		"camerashake" : false,
		"camerashakeamplitude" : 0.5,
		"camerashakeroughness" : 1.0,
		"camerashakespeed" : 3.0,
		"clearcolor" : "0.125 0.098 0.204",
		"clearenabled" : true,
		"farz" : 10000.0,
		"fov" : 53.0,
		"nearz" : 0.10000000149011612,
		"orthogonalprojection" : null,
		"skylightcolor" : "1.000 1.000 1.000"
	},
	"objects" : 
	[
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 16,
			"image" : "models/ps2menu.json",
			"locktransforms" : false,
			"name" : "Clouds (master script)",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "10.000 10.000 10.000",
			"size" : "256.000 256.000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nimport * as WEMath from 'WEMath';\nimport * as OMGVector from 'OMGVector';\nimport Mat4 from 'OMGMatrix';\n\n// Properties\nconst numPrisms = 12;\nconst prismDist = 8;\nconst prismScale = new Vec3(0.1, 0.09, 0.1);\n\n// Prism parent rotation\nconst prismRotSpeed = new Vec3(0, 10, 15);\n\n// Prism rotation about local axis\nconst prismLocalRotSpeed = new Vec3(0, 30, 0);\n\nconst numOrbs = 7;\nconst orbDist = 5;\n\n// Orb parent rotation (z rotation offset based on orb index)\nconst orbRotSpeed = new Vec3(0, 110, 90);\n\n\n\n\n// Consts\nconst sec2Min = 0.016666666667;\nconst deg2rad = WEMath.deg2rad;\n\n// Register assets and their children\nconst prismAsset = engine.registerAsset(\"models/prism/prism.mdl\");\nconst orbAsset = engine.registerAsset(\"particles/orb.json\");\n\tengine.registerAsset(\"orbTrail.json\");\n\tengine.registerAsset(\"orbGlow.json\");\n\n\n// Objects\nlet prisms = [];\nlet prismRot = new Vec3(0, 0, 0);\nlet orbs = [];\nlet orbRot = new Vec3(0, 0, 0);\n\n\n// Classes\nclass Prism {\n\tconstructor(offset, angles){\n\t\tthis.layer = thisScene.createLayer(prismAsset);\n\t\tthis.offset = offset;\n\t\tthis.angles = angles;\n\t}\n}\n\nclass Orb {\n\tconstructor(offset){\n\t\tthis.layer = thisScene.createLayer(orbAsset);\n\t\tthis.offset = offset;\n\t}\n}\n\n/**\n * @param {Boolean} value (for property 'visible')\n */\nexport function init(value) {\n\tfor (let i = 0; i < numPrisms; i++)\n\t{\n\t\tprisms[i] = new Prism();\n\t\tprisms[i].layer.scale = prismScale;\n\t\t\n\t\tlet angle = i * 360 / numPrisms;\n\t\tprisms[i].angles = new Vec3(0, 0, angle);\n\n\t\tlet finalTransform = new Mat4();\n\t\tfinalTransform = finalTransform.multiply(new Mat4(prisms[i].angles, \"euler\", \"XYZ\"));\n\t\tfinalTransform = finalTransform.multiply(new Mat4(new Vec3(0, prismDist, 0), \"position\"));\n\t\tprisms[i].offset = finalTransform.toPosition();\n\t}\n\tfor (let i = 0; i < numOrbs; i++)\n\t{\n\t\torbs[i] = new Orb();\n\t\t\n\t\tlet angleZ = (i+1) * engine.runtime * 360. * sec2Min * 2.0;\n\t\tlet finalAngles = new Vec3(orbRot.x, orbRot.y, orbRot.z + angleZ);\n\t\torbs[i].offset = new Vec3(0, orbDist, 0);\n\n\t\tlet finalTransform = new Mat4();\n\t\tfinalTransform = finalTransform.multiply(new Mat4(finalAngles, \"euler\", \"XYZ\"));\n\t\tfinalTransform = finalTransform.multiply(new Mat4(orbs[i].offset, \"position\"));\n\n\t\torbs[i].layer.origin = finalTransform.toPosition();\n\t}\n\treturn value;\n}\n\nexport function update(value) {\n\tprismRot = prismRot.add(prismRotSpeed.multiply(engine.frametime));\n\torbRot = orbRot.add(orbRotSpeed.multiply(engine.frametime));\n\n\t// Update Prisms\n\tfor (let i = 0; i < prisms.length; i++)\n\t{\n\t\tprisms[i].angles = prisms[i].angles.add(prismLocalRotSpeed.multiply(engine.frametime));\n\n\t\tlet finalTransform = new Mat4();\n\t\tfinalTransform = finalTransform.multiply(new Mat4(prismRot, \"euler\", \"ZYX\"));\n\t\tfinalTransform = finalTransform.multiply(new Mat4(prisms[i].offset, \"position\"));\n\t\tfinalTransform = finalTransform.multiply(new Mat4(prisms[i].angles, \"euler\", \"ZYX\"));\n\n\t\tprisms[i].layer.angles = finalTransform.toEuler(\"ZYX\");\n\t\tprisms[i].layer.origin = finalTransform.toPosition();\n\t}\n\n\t// Update orbs\n\tfor (let i = 0; i < orbs.length; i++)\n\t{\n\t\tlet angleZ = (i+1) * engine.runtime * 360. * sec2Min * 2.0;\n\t\tlet finalAngles = new Vec3(orbRot.x, orbRot.y, orbRot.z + angleZ);\n\n\t\tlet finalTransform = new Mat4();\n\t\tfinalTransform = finalTransform.multiply(new Mat4(finalAngles, \"euler\", \"XYZ\"));\n\t\tfinalTransform = finalTransform.multiply(new Mat4(orbs[i].offset, \"position\"));\n\n\t\torbs[i].layer.origin = finalTransform.toPosition();\n\t}\n\treturn value;\n}",
				"value" : true
			}
		}
	]
}