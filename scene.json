{
	"camera" : 
	{
		"center" : "0.000 0.000 50.000",
		"eye" : "0.000 0.000 51.000",
		"paths" : [ "scripts/camera_00.json" ],
		"up" : "0.000 1.000 0.000"
	},
	"general" : 
	{
		"ambientcolor" : "0.302 0.302 0.302",
		"bloom" : false,
		"bloomstrength" : 3.0099999904632568,
		"bloomthreshold" : 0.69999998807907104,
		"camerafade" : false,
		"cameraparallax" : false,
		"cameraparallaxamount" : 0.5,
		"cameraparallaxdelay" : 0.10000000149011612,
		"cameraparallaxmouseinfluence" : 0.0,
		"camerapreview" : false,
		"camerashake" : false,
		"camerashakeamplitude" : 0.5,
		"camerashakeroughness" : 1.0,
		"camerashakespeed" : 3.0,
		"clearcolor" : "0.125 0.098 0.204",
		"clearenabled" : true,
		"farz" : 10000.0,
		"fov" : 53.0,
		"nearz" : 0.10000000149011612,
		"orthogonalprojection" : null,
		"skylightcolor" : "1.000 1.000 1.000"
	},
	"objects" : 
	[
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 16,
			"image" : "models/ps2menu.json",
			"locktransforms" : false,
			"name" : "Clouds",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "10.000 10.000 10.000",
			"size" : "256.000 256.000",
			"solid" : true,
			"visible" : true
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 18,
			"locktransforms" : false,
			"model" : "models/empty.mdl",
			"name" : "Prisms (script)",
			"origin" : 
			{
				"script" : "'use strict';\nimport * as WEMath from 'WEMath';\nimport * as OMGVector from 'OMGVector';\nimport Mat4 from 'OMGMatrix';\n\n// Properties\nconst numPrisms = 12;\nconst prismDist = 8;\nconst prismScale = new Vec3(0.1, 0.09, 0.1);\n\n// Parent rotation\nconst angleSpeed = new Vec3(0, 10, 15);\n\n// Prism local axis rotation\nconst prismAngleSpeed = new Vec3(0, 30, 0);\n\n\n\n// Consts\nconst sec2Min = 0.016666666667;\nconst deg2rad = WEMath.deg2rad;\n\n// Register assets and their children\nconst prismAsset = engine.registerAsset(\"models/prism/prism.mdl\");\n\n// Prism Objects\nclass Prism {\n\tconstructor(offset, angles){\n\t\tthis.layer = thisScene.createLayer(prismAsset);\n\t\tthis.offset = offset;\n\t\tthis.angles = angles;\n\t}\n}\n// Array of prisms\nlet prisms = [];\n\n\n\n/**\n * @param {Vec3} value (for property 'origin')\n */\nexport function init(value) {\n\tlet parentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\tparentTransform = parentTransform.multiply(Mat4.fromEuler(thisLayer.angles), \"XYZ\");\n\n\tfor (let i = 0; i < numPrisms; i++)\n\t{\n\t\tprisms[i] = new Prism();\n\t\tprisms[i].layer.scale = prismScale;\n\t\t\n\t\tlet angle = i * 360 / numPrisms;\n\t\tprisms[i].angles = new Vec3(0, 0, angle);\n\n\t\tlet localTransform = new Mat4();\n\t\tlocalTransform = localTransform.multiply(Mat4.fromEuler(prisms[i].angles, \"XYZ\"));\n\t\tlocalTransform = localTransform.multiply(Mat4.fromPosition(new Vec3(0, prismDist, 0)));\n\n\t\tprisms[i].offset = localTransform.toPosition();\n\n\t\tlet prismTransform = parentTransform.multiply(localTransform);\n\t}\n\treturn value;\n}\n\n/**\n * @param {Vec3} value (for property 'origin')\n */\nexport function update(value) {\n\tthisLayer.angles = thisLayer.angles.add( angleSpeed.multiply(engine.frametime) );\n\tlet parentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\tparentTransform = parentTransform.multiply(Mat4.fromEuler(thisLayer.angles), \"XYZ\");\n\t\n\t// Update Prisms\n\tfor (let i = 0; i < prisms.length; i++)\n\t{\n\t\tprisms[i].angles = prisms[i].angles.add(prismAngleSpeed.multiply(engine.frametime));\n\n\t\tlet prismTransform = new Mat4();\n\t\tprismTransform = prismTransform.multiply(parentTransform);\n\t\tprismTransform = prismTransform.multiply(Mat4.fromPosition(prisms[i].offset));\n\t\tprismTransform = prismTransform.multiply(Mat4.fromEuler(prisms[i].angles, \"ZYX\"));\n\n\t\tprisms[i].layer.angles = prismTransform.toEuler(\"ZYX\");\n\t\tprisms[i].layer.origin = prismTransform.toPosition();\n\t}\n\n\treturn value;\n}\n",
				"value" : "-5.500 0.000 0.000"
			},
			"parallaxDepth" : "1.000 1.000",
			"scale" : "1.000 1.000 1.000"
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 39,
			"locktransforms" : false,
			"model" : "models/empty.mdl",
			"name" : "Orbs (script)",
			"origin" : 
			{
				"script" : "'use strict';\nimport * as WEMath from 'WEMath';\nimport * as OMGVector from 'OMGVector';\nimport Mat4 from 'OMGMatrix';\n\n// Properties\nconst numOrbs = 7;\nconst orbDist = 5;\n\n// Orb parent rotation (z rotation offset based on orb index)\nconst angleSpeed = new Vec3(0, 110, 90);\n\n\n\n\n// Consts\nconst sec2Min = 0.016666666667;\nconst deg2rad = WEMath.deg2rad;\n\n// Register assets and their children\nconst orbAsset = engine.registerAsset(\"particles/orb.json\");\n\tengine.registerAsset(\"orbTrail.json\");\n\tengine.registerAsset(\"orbGlow.json\");\n\n\n// Objects\nlet orbs = [];\n\n\n// Classes\nclass Orb {\n\tconstructor(offset){\n\t\tthis.layer = thisScene.createLayer(orbAsset);\n\t\tthis.offset = offset;\n\t}\n}\n\n/**\n * @param {Boolean} value (for property 'visible')\n */\nexport function init(value) {\n\tlet parentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\n\tfor (let i = 0; i < numOrbs; i++)\n\t{\n\t\torbs[i] = new Orb();\n\t\t\n\t\tlet angleZ = (i+1) * engine.runtime * 360. * sec2Min * 2.0;\n\t\tlet finalAngles = thisLayer.angles.add(new Vec3(0, 0, angleZ));\n\t\torbs[i].offset = new Vec3(0, orbDist, 0);\n\t\tlet finalParentTransform = parentTransform.multiply(Mat4.fromEuler(finalAngles), \"XYZ\");\n\n\t\tlet localTransform = new Mat4();\n\t\tlocalTransform = localTransform.multiply(Mat4.fromPosition(orbs[i].offset));\n\n\t\tlet finalTransform = finalParentTransform.multiply(localTransform);\n\n\t\torbs[i].layer.origin = finalTransform.toPosition();\n\t}\n\treturn value;\n}\n\nexport function update(value) {\n\tthisLayer.angles = thisLayer.angles.add( angleSpeed.multiply(engine.frametime) );\n\tlet parentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\n\tfor (let i = 0; i < orbs.length; i++)\n\t{\n\t\tlet angleZ = (i+1) * engine.runtime * 360. * sec2Min * 2.0;\n\t\tlet finalAngles = thisLayer.angles.add(new Vec3(0, 0, angleZ));\n\t\tlet finalParentTransform = parentTransform.multiply(Mat4.fromEuler(finalAngles), \"XYZ\");\n\n\t\tlet localTransform = new Mat4();\n\t\tlocalTransform = localTransform.multiply(Mat4.fromPosition(orbs[i].offset));\n\n\t\tlet finalTransform = finalParentTransform.multiply(localTransform);\n\n\t\torbs[i].layer.origin = finalTransform.toPosition();\n\t}\n\treturn value;\n}",
				"value" : "-5.500 0.000 0.000"
			},
			"parallaxDepth" : "1.000 1.000",
			"scale" : "1.000 1.000 1.000"
		}
	]
}