{
	"camera" : 
	{
		"center" : "0.000 0.000 37.000",
		"eye" : "0.000 0.000 38.000",
		"paths" : [ "scripts/camera_00.json" ],
		"up" : "0.000 1.000 0.000"
	},
	"general" : 
	{
		"ambientcolor" : "0.302 0.302 0.302",
		"bloom" : true,
		"bloomstrength" : 3.5,
		"bloomthreshold" : 0.89999997615814209,
		"camerafade" : false,
		"cameraparallax" : false,
		"cameraparallaxamount" : 0.5,
		"cameraparallaxdelay" : 0.10000000149011612,
		"cameraparallaxmouseinfluence" : 0.0,
		"camerapreview" : false,
		"camerashake" : false,
		"camerashakeamplitude" : 0.5,
		"camerashakeroughness" : 1.0,
		"camerashakespeed" : 3.0,
		"clearcolor" : "0.125 0.098 0.204",
		"clearenabled" : true,
		"farz" : 1000.0,
		"fov" : 53.0,
		"nearz" : 1.0,
		"orthogonalprojection" : null,
		"skylightcolor" : "1.000 1.000 1.000"
	},
	"objects" : 
	[
		{
			"angles" : "0.000 0.000 0.000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 16,
			"image" : "models/ps2menu.json",
			"locktransforms" : false,
			"name" : "Clouds",
			"origin" : "0.000 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"scale" : "10.000 10.000 10.000",
			"size" : "256.000 256.000",
			"solid" : true,
			"visible" : true
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 64,
			"locktransforms" : false,
			"model" : "models/prism/prism.mdl",
			"name" : "mainPrism",
			"origin" : "0.216 0.000 0.000",
			"parallaxDepth" : "1.000 1.000",
			"scale" : "1.000 1.000 1.000",
			"skin" : 1
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 18,
			"locktransforms" : false,
			"model" : "models/empty.mdl",
			"name" : "Prisms (script)",
			"origin" : 
			{
				"script" : "'use strict';\nimport * as WEMath from 'WEMath';\nimport * as OMGVector from 'OMGVector';\nimport Mat4 from 'OMGMatrix';\n\n// Properties\nconst numPrisms = 12;\nconst prismDist = 8;\nconst prismScale = new Vec3(1.0, 0.9, 1.0);\n\n// Parent rotation\nconst angleSpeed = new Vec3(0, 10, 15);\nconst angleRigidity = 3.0; // Smoothing disabled due to gimbal issues\nlet targetAngles = new Vec3(0, 0, 0);\n\n// Prism local axis rotation\nconst prismAngleSpeed = new Vec3(0, 20, 0);\n\n\n\n// Math Constants\nconst sec2Min = 0.016666666667;\nconst deg2rad = WEMath.deg2rad;\n\n// Register asset\nconst prismAsset = engine.registerAsset(\"models/prism/prism.mdl\");\n//const prism2Asset = engine.registerAsset(\"models/prism2/prism2.mdl\");\n\n\n // Pseudo-enum\nconst modes = {\n\tCLOCK: {\n\t\tSMOOTH: \"clock.smooth\",\n\t\tCLICK: \"clock.click\"\n\t},\n\tAUDIO: \"audio\"\n};\n// User Properties\nlet mode = modes.CLOCK.SMOOTH;\n\n// Prism Object\nclass Prism {\n\tconstructor(offset, angles){\n\t\tthis.layer = thisScene.createLayer(prismAsset);\n\t\tthis.offset = offset;\n\t\tthis.angles = angles;\n\t}\n}\nclass MainPrism { // head prism of the clock\n\tconstructor(offset, angles){\n\t\tthis.layer = thisScene.getLayer(\"mainPrism\");\n\t\tthis.offset = offset;\n\t\tthis.angles = angles;\n\t}\n}\n// Array of prisms\nlet prisms = [];\n\n/**\n * @param {Vec3} value (for property 'origin')\n */\nexport function init(value) {\n\tfor (let i = 0; i < numPrisms; i++)\n\t{\n\t\tif (i === 0)\n\t\t\tprisms[i] = new MainPrism();\n\t\telse\n\t\t\tprisms[i] = new Prism();\n\n\t\tprisms[i].layer.scale = prismScale;\n\t\t\n\t\tlet angle = i * 360 / numPrisms;\n\t\tprisms[i].angles = new Vec3(0, 0, angle);\n\n\t\tlet localTransform = new Mat4();\n\t\tlocalTransform = localTransform.multiply(Mat4.fromEuler(prisms[i].angles, \"XYZ\"));\n\t\tlocalTransform = localTransform.multiply(Mat4.fromPosition(new Vec3(0, prismDist, 0)));\n\n\t\tprisms[i].offset = localTransform.toPosition();\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Vec3} value (for property 'origin')\n */\nexport function update(value) {\n\t// Parent object rotation\n\tlet currentDateTime = new Date();\n\tswitch (mode){\n\t\tcase modes.CLOCK.SMOOTH:\n\t\t\tlet yaw = -(currentDateTime.getSeconds() + currentDateTime.getMilliseconds() * .001) * 6;\n\t\t\tlet roll = -currentDateTime.getHours() % 12 * 30;\n\t\t\tlet clockTransform = new Mat4();\n\t\t\tclockTransform = clockTransform.multiply(Mat4.fromEuler(new Vec3(0, yaw, roll), \"ZYX\"));\n\t\t\ttargetAngles = clockTransform.toEuler(\"XYZ\");\n\t\t\tbreak;\n\t\tcase modes.CLOCK.CLICK:\n\t\t\ttargetAngles = new Vec3(0, currentDateTime.getSeconds() * 6, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttargetAngles = targetAngles.add( angleSpeed.multiply(engine.frametime) );\n\t\t\tbreak;\n\t}\n\tthisLayer.angles = targetAngles;//OMGVector.interpAngle(thisLayer.angles, targetAngles, Math.min(1.0, angleRigidity * engine.frametime));\n\tlet parentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\tparentTransform = parentTransform.multiply(Mat4.fromEuler(thisLayer.angles, \"XYZ\"));\n\t\n\t// Update Prisms\n\tfor (let i = 0; i < prisms.length; i++)\n\t{\n\t\tprisms[i].angles = prisms[i].angles.add(prismAngleSpeed.multiply(engine.frametime));\n\n\t\tlet prismTransform = new Mat4();\n\t\tprismTransform = prismTransform.multiply(parentTransform);\n\t\tprismTransform = prismTransform.multiply(Mat4.fromPosition(prisms[i].offset));\n\t\tprismTransform = prismTransform.multiply(Mat4.fromEuler(prisms[i].angles, \"ZYX\"));\n\n\t\tprisms[i].layer.angles = prismTransform.toEuler(\"ZYX\");\n\t\tprisms[i].layer.origin = prismTransform.toPosition();\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\t//mode = userProperties.mode;\n}\n",
				"value" : "-5.500 0.000 0.000"
			},
			"parallaxDepth" : "1.000 1.000",
			"scale" : "1.000 1.000 1.000"
		},
		{
			"angles" : "0.000 0.000 0.000",
			"id" : 39,
			"locktransforms" : false,
			"model" : "models/empty.mdl",
			"name" : "Orbs (script)",
			"origin" : 
			{
				"script" : "'use strict';\nimport * as WEMath from 'WEMath';\nimport * as OMGVector from 'OMGVector';\nimport Mat4 from 'OMGMatrix';\n\n// Properties\nconst numOrbs = 7;\nconst orbDist = 5;\n\n// Orb parent rotation (z rotation offset based on orb index)\nconst angleSpeed = new Vec3(0, 110, 90);\n\n\n\n\n// Consts\nconst sec2Min = 0.016666666667;\nconst deg2rad = WEMath.deg2rad;\n\n// Register assets and their children\nconst orbAsset = engine.registerAsset(\"particles/orb.json\");\n\tengine.registerAsset(\"orbTrail.json\");\n\tengine.registerAsset(\"orbGlow.json\");\n\n\n// Objects\nlet orbs = [];\n\n\n// Classes\nclass Orb {\n\tconstructor(offset){\n\t\tthis.layer = thisScene.createLayer(orbAsset);\n\t\tthis.offset = offset;\n\t}\n}\n\n/**\n * @param {Boolean} value (for property 'visible')\n */\nexport function init(value) {\n\tlet parentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\n\tfor (let i = 0; i < numOrbs; i++)\n\t{\n\t\torbs[i] = new Orb();\n\t\t\n\t\tlet angleZ = (i+1) * engine.runtime * 360. * sec2Min;\n\t\tlet finalAngles = thisLayer.angles.add(new Vec3(0, 0, angleZ));\n\t\torbs[i].offset = new Vec3(0, orbDist, 0);\n\t\tlet finalParentTransform = parentTransform.multiply(Mat4.fromEuler(finalAngles), \"XYZ\");\n\n\t\tlet localTransform = new Mat4();\n\t\tlocalTransform = localTransform.multiply(Mat4.fromPosition(orbs[i].offset));\n\n\t\tlet finalTransform = finalParentTransform.multiply(localTransform);\n\n\t\torbs[i].layer.origin = finalTransform.toPosition();\n\t}\n\treturn value;\n}\n\nexport function update(value) {\n\tthisLayer.angles = thisLayer.angles.add( angleSpeed.multiply(engine.frametime) );\n\tlet parentTransform = new Mat4();\n\tparentTransform = parentTransform.multiply(Mat4.fromPosition(thisLayer.origin));\n\n\tfor (let i = 0; i < orbs.length; i++)\n\t{\n\t\tlet angleZ = (i+1) * engine.runtime * 360. * sec2Min;\n\t\tlet finalAngles = thisLayer.angles.add(new Vec3(0, 0, angleZ));\n\t\tlet finalParentTransform = parentTransform.multiply(Mat4.fromEuler(finalAngles), \"XYZ\");\n\n\t\tlet localTransform = new Mat4();\n\t\tlocalTransform = localTransform.multiply(Mat4.fromPosition(orbs[i].offset));\n\n\t\tlet finalTransform = finalParentTransform.multiply(localTransform);\n\n\t\torbs[i].layer.origin = finalTransform.toPosition();\n\t}\n\treturn value;\n}",
				"value" : "-5.500 0.000 0.000"
			},
			"parallaxDepth" : "1.000 1.000",
			"scale" : "1.000 1.000 1.000"
		},
		{
			"alpha" : 0.89999997615814209,
			"anchor" : "topleft",
			"angles" : "0.000 0.000 0.000",
			"backgroundcolor" : "0.000 0.000 0.000",
			"color" : "0.875 0.875 0.875",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/blurprecise/effect.json",
					"id" : 57,
					"name" : "",
					"passes" : 
					[
						{
							"combos" : 
							{
								"KERNEL" : 2
							},
							"constantshadervalues" : 
							{
								"scale" : "2 2"
							},
							"id" : 60
						},
						{
							"combos" : 
							{
								"KERNEL" : 2,
								"VERTICAL" : 1
							},
							"constantshadervalues" : 
							{
								"scale" : "2 2"
							},
							"id" : 61
						}
					],
					"visible" : true
				}
			],
			"font" : "fonts/NimbusSanL-Reg.ttf",
			"horizontalalign" : "left",
			"id" : 48,
			"locktransforms" : true,
			"name" : "Current Date",
			"opaquebackground" : false,
			"origin" : "-14.000 10.000 15.000",
			"padding" : 4,
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"pointsize" : 
			{
				"user" : "text_size",
				"value" : 35.0
			},
			"scale" : "0.010 0.010 0.010",
			"size" : "736.000 183.000",
			"solid" : true,
			"text" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tlet ratio = size.x / size.y;\n\tthisLayer.origin = new Vec3(-11 * ratio, 10.5, 15); \n}\n\n/**\n * @param {String} value (for property 'text')\n */\nexport function update(value) {\n\tlet dateTime = new Date();\n\tlet year = dateTime.getFullYear();\n\tlet month = dateTime.getMonth() + 1;\n\tif (month < 10) month = \"0\" + month;\n\tlet day = dateTime.getDate();\n\tif (day < 10) day = \"0\" + day;\n\treturn year + \"/\" + month + \"/\" + day;\n}\n/**\n * @param {String} value (for property 'text')\n */\nexport function init(value) {\n\tresizeScreen(engine.screenResolution);\n\treturn value;\n}\n",
				"value" : "0000/00/00"
			},
			"verticalalign" : "top",
			"visible" : 
			{
				"user" : "show_clock_text",
				"value" : true
			}
		},
		{
			"alpha" : 0.89999997615814209,
			"anchor" : "topleft",
			"angles" : "0.000 0.000 0.000",
			"backgroundcolor" : "0.000 0.000 0.000",
			"color" : "0.875 0.875 0.875",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/blurprecise/effect.json",
					"id" : 71,
					"name" : "",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"scale" : "2 2"
							},
							"id" : 72
						},
						{
							"combos" : 
							{
								"VERTICAL" : 1
							},
							"constantshadervalues" : 
							{
								"scale" : "2 2"
							},
							"id" : 73
						}
					],
					"visible" : true
				}
			],
			"font" : "fonts/NimbusSanL-Reg.ttf",
			"horizontalalign" : "right",
			"id" : 19,
			"locktransforms" : true,
			"name" : "Current Time",
			"opaquebackground" : false,
			"origin" : "14.000 10.000 15.000",
			"padding" : 4,
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"pointsize" : 
			{
				"user" : "text_size",
				"value" : 35.0
			},
			"scale" : "0.010 0.010 0.010",
			"size" : "574.000 183.000",
			"solid" : true,
			"text" : 
			{
				"script" : "'use strict';\n\nlet militaryTime = false;\nlet ampm = \"am\";\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tlet ratio = size.x / size.y;\n\tthisLayer.origin = new Vec3(11 * ratio, 10.5, 15); \n}\n\n/**\n * @param {String} value (for property 'text')\n */\nexport function update(value) {\n\tlet dateTime = new Date();\n\tlet hour = dateTime.getHours();\n\tif (!militaryTime){\n\t\tif (hour > 12)\n\t\t\tampm = \"PM\";\n\t\telse\n\t\t\tampm = \"AM\";\n\t\thour = hour % 12;\n\t}\n\t//if (hour < 10) hour = \"0\" + hour;\n\tlet minute = dateTime.getMinutes();\n\tif (minute < 10) minute = \"0\" + minute;\n\tlet second = dateTime.getSeconds();\n\tif (second < 10) second = \"0\" + second;\n\n\tlet time = hour + \":\" + minute + \":\" + second;\n\tif (!militaryTime)\n\t\ttime = time + \" \" + ampm;\n\treturn time;\n}\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tresizeScreen(engine.screenResolution);\n\tmilitaryTime = userProperties.clock_24_hour;\n}",
				"value" : "00:00:00"
			},
			"verticalalign" : "top",
			"visible" : 
			{
				"user" : "show_clock_text",
				"value" : true
			}
		},
		{
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/filmgrain/effect.json",
					"id" : 68,
					"name" : "",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"scale" : 10,
								"strength" : 
								{
									"user" : "film_grain",
									"value" : 0.38
								}
							},
							"id" : 70,
							"textures" : [ null, "util/noise" ]
						}
					],
					"visible" : true
				}
			],
			"id" : 63,
			"image" : "models/util/fullscreenlayer.json",
			"locktransforms" : false,
			"name" : "Film Grain",
			"parallaxDepth" : "1.000 1.000",
			"perspective" : false,
			"solid" : true,
			"visible" : true
		}
	]
}